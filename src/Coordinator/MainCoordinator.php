<?php
/**
 * @package     Joomla\Testing
 * @subpackage  Coordinator
 *
 * @copyright   Copyright (C) 2005 - 2016 Open Source Matters, Inc. All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE.txt
 */

namespace Joomla\Testing\Coordinator;

use Joomla\Testing\Util\Command;
use Joomla\Virtualisation\DockerComposeGeneratorAPI;
use Joomla\Testing\Coordinator\Task;


//TODO(improvement) -> reuse memcache instance when possible, especially manageTask;

/**
 * Class MainCoordinator
 *
 * In charge of coordinativ the parallel testing environment
 * It is a static class(all of its methods are static) because it will be use asynchronously in robo tasks,
 * also it holds no information by itself, all data is stored in a persistent data storage (memcached)
 *
 * @package Joomla\Testing\Coordinator
 */
class MainCoordinator
{
	/**
	 * Cache keys
	 */
	const SELECTION_LISTS = 'selectionlists';
	const CLIENTS = 'clients';
	const SERVERS = 'servers';
	const RUN_QUEUE = 'runQueue';
	const MANAGE_QUEUE = 'manageQueue';
	const CLIENTS_NO = 'clientsNo';
	const SERVERS_NO = 'serversNo';
	const AVAILABLE = 'available';

	/**
	 * memcached connection information
	 */
	const MEMCACHED_HOST = '127.0.0.1';
	const MEMCACHED_PORT = '11211';


	/**
	 * Prepares the testing information and stores is in cache
	 * Waits for database init in order to assure servers load
	 *
	 * @param $env
	 */
	public function prepare($env)
	{
//		echo "prepare\n";
		/**
		 * list of server containers names
		 */
		$servers = array();
		/**
		 * list of client containers names
		 */
		$clients = array();
		/**
		 * list of selection lists
		 * stores all the SelectionLists for further manipulation
		 */
		$selectionLists = array();
		/**
		 * stores the tasks ready to be executed
		 * limited in size to the total number of clients
		 */
		$runQueue = new \SplQueue();
		/**
		 * stores the server containers names
		 * it is user to ensure an even distribution of tasks across clients
		 */
		$manageQueue= new \SplQueue();
		/**
		 * number of selenium containers(clients)
		 */
		$clientsNo = $env['selenium.no'];
		/**
		 * number of server containers
		 */
		$serversNo = 0;

		//TODO How are these exactly generated?
		//TODO How to run multiple environments on the same machine
		$prefix = "dockyard_";
		$postfix = "_1";

		/**
		 * converts config server name to container name generated by the virtualisation package
		 *
		 * @param $name
		 * @return string
		 */
		$fixName  = function ($name)
		{
			return strtolower(str_replace(['-', '.'], ['v', 'p'], $name));
		};

		foreach ($env['php'] as $php)
		{
			foreach ($env['joomla'] as $joomla)
			{
				$name = $prefix . $fixName('apache-' . $php . '-' . $joomla) . $postfix;
				$servers[] = $name;
				$selectionLists[$name] = new SelectionList($env["extension.path"] . "/tests/acceptance/tests.yml");
				$manageQueue->enqueue($name);
				$serversNo ++;
				$this->prepareCodeception($env["extension.path"] . "/tests/_envs", "env.dist.yml", $name);
				$this->prepareCodeception($env["extension.path"] . "/tests/_configs", "codeception.dist.yml", $name);
			}
		}

		for ($i=0; $i<$clientsNo; $i++)
		{
			$clients[$prefix . "seleniumv$i" .$postfix] = 1;
		}

		$info = array(
			$this::SELECTION_LISTS => $selectionLists,
			$this::CLIENTS 		=> $clients,
			$this::SERVERS 		=> $servers,
			$this::RUN_QUEUE		=> $runQueue,
			$this::MANAGE_QUEUE	=> $manageQueue,
			$this::CLIENTS_NO		=> $clientsNo,
			$this::SERVERS_NO		=> $serversNo,
			$this::AVAILABLE		=> 1
		);

		$memcached = new Storage($this::MEMCACHED_HOST, $this::MEMCACHED_PORT);
		$memcached->setCacheInfo($info);

		$this->havingStartNetwork($servers[0], current(array_keys($clients)));

//		echo "done preparing\n";
	}

	/**
	 *
	 * fills the execution queue(runQueue)
	 * runs tasks if possible
	 * prints logs after server tasks are finished
	 *
	 * @param null $server
	 */
	public function fillAndRun($server = null)
	{
//		echo "fillAndRun\n";
		$memcached = new Storage($this::MEMCACHED_HOST, $this::MEMCACHED_PORT);
		$info = $memcached->getCachedInfo();
		$info = $this->fill($info, $server);
		$info = $this->run($info);

		if (isset($server) && $info[$this::SELECTION_LISTS][$server]->isFinished())
		{
			echo "Results on server $server are:\n";
			echo "Executed" . $info[$this::SELECTION_LISTS][$server]->getNoExecuted() . "\n";
			echo "Failed " . $info[$this::SELECTION_LISTS][$server]->getNoFailed() . "\n";
			echo "Total " . $info[$this::SELECTION_LISTS][$server]->getNoTasks() . "\n\n";
		}

		$memcached->setCacheInfo($info);
	}

	/**
	 * changes the status of a task
	 *
	 * @param $codeceptionTask
	 * @param $server
	 * @param $client
	 * @param $action
	 */
	public function changeTaskStatus($codeceptionTask, $server, $client, $action)
	{
		$memcached = new Storage($this::MEMCACHED_HOST, $this::MEMCACHED_PORT);
		$memcached->changeTaskStatus($codeceptionTask, $server, $client, $action);
	}

	/**
	 * generates the execution environment using the virtualisation package
	 *
	 * @param $env
	 * @param $dockyardPath
	 */
	public function generateEnv($env, $dockyardPath)
	{
		(new DockerComposeGeneratorAPI())->generateFromConfig($env, $dockyardPath);

		$command = "cd " . $dockyardPath . "&& docker-compose up -d";

		Command::execute($command);
	}


	/**
	 * called when a task changes status
	 * by design, it also fills the queue and run tasks if possible
	 *
	 * @param $codeceptionTask
	 * @param $server
	 * @param $client
	 * @param $action
	 */
	public function manageTask($codeceptionTask, $server, $action, $client = null)
	{
		$this->changeTaskStatus($codeceptionTask, $server, $client, $action);
		echo "$server $action $codeceptionTask with client $client\n";
		$this->fillAndRun($server);
	}

	/**
	 * fills the execution queue
	 *
	 * @param $info
	 * @param null $server
	 * @return mixed
	 */
	private function fill($info, $server = null)
	{
//		echo "start filling\n";
		$globalCount = 0;

		if($server && $info[$this::RUN_QUEUE]->count() < $info[$this::CLIENTS_NO])
		{
			if ($codeceptionTask = $info[$this::SELECTION_LISTS][$server]->pop())
			{
				$task = new Task($codeceptionTask, $server);
//				echo "added task\n";
				$info[$this::RUN_QUEUE]->add(0, $task);
				$info[$this::SELECTION_LISTS][$server]->assign($codeceptionTask);
				echo "$server assign $codeceptionTask\n";

				$globalCount++;
			}
		}

		// count is used for checking if there is any test available in all the selection lists, if not, exit the while
		$count = 1;
		while ($info[$this::RUN_QUEUE]->count() < $info[$this::CLIENTS_NO] && $count)
		{
			$count = 0;
			for($i=0; $i< $info[$this::SERVERS_NO]; $i++)
			{
				$server = $info[$this::MANAGE_QUEUE]->pop();
				if ($codeceptionTask = $info[$this::SELECTION_LISTS][$server]->pop())
				{
					$task = new Task($codeceptionTask, $server);
					$info[$this::RUN_QUEUE]->add(0, $task);
					$info[$this::SELECTION_LISTS][$server]->assign($codeceptionTask);
					echo "$server assign $codeceptionTask\n";
					$count ++;
//					echo "added task\n";
					$globalCount++;
				}

				$info[$this::MANAGE_QUEUE]->add(0, $server);
			}
		}
//		echo "done filling - added $globalCount tasks\n";
		return $info;
	}

	/**
	 * runs tasks if clients and tasks are available
	 *
	 * @param $info
	 * @return mixed
	 */
	private function run($info)
	{
//		echo "start running\n";
		$globalCount = 0;

		foreach ($info[$this::CLIENTS] as $client => $isAvailable)
		{
			if ($info[$this::RUN_QUEUE]->isEmpty()) break;
			if ($isAvailable == 1)
			{
				$task = $info[$this::RUN_QUEUE]->pop();
				$task->run($client);
				//marks client as not available
				$info[$this::CLIENTS][$client] = 0;
//				echo "run task ". $task->getTask()." \n";
				$globalCount++;
			}
		}

//		echo "runned $globalCount tasks\n";

		return $info;
	}

	//TODO make this check by looking at db, instead of servers.

	/**
	 * waits for database container initiation (loading the sql dump)
	 *
	 * @param $server
	 * @param $client
	 */
	private function havingStartNetwork($server, $client)
	{
		while (!$this->isUrlAvailable($server, $client))
		{
			sleep(1);
		}

		echo "db init finished\n";
	}

	/**
	 * Checks if the given URL is available
	 *
	 * @param   string  $url  URL to check
	 *
	 * @return bool
	 */
	private function isUrlAvailable($url, $client)
	{
		$command = "docker exec " . $client . " /bin/sh -c \"curl -sL -w \"%{http_code}\\n\" -o /dev/null http://" . $url . "\"";

		$code = Command::executeWithOutput($command);

		return $code == 200;
	}

	private function prepareCodeception($path, $file, $server)
	{
		$templateFile = "$path/$file";
		$resultFile = "$path/$server.yml";
		$initialSuite = fopen($templateFile, "r") or die("Unable to open file!");
		$txt = fread($initialSuite, filesize($templateFile));
		fclose($initialSuite);

		$finalSuite = fopen($resultFile, "w") or die("Unable to open file!");
		$txt = str_replace("###", $server, $txt);
		fwrite($finalSuite, $txt);
		fclose($finalSuite);
	}

}